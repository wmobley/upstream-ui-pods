/* tslint:disable */
/* eslint-disable */
/**
 * Upstream Sensor Storage
 * Sensor Storage for Upstream data
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: wmobley@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface AggregatedMeasurement
 */
export interface AggregatedMeasurement {
    /**
     * 
     * @type {Date}
     * @memberof AggregatedMeasurement
     */
    measurementTime: Date;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    value: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    medianValue: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    pointCount: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    lowerBound: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    upperBound: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    parametricLowerBound: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    parametricUpperBound: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    stdDev: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    minValue: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    maxValue: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    percentile25: number;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    percentile75: number;
    /**
     * 
     * @type {string}
     * @memberof AggregatedMeasurement
     */
    ciMethod: string;
    /**
     * 
     * @type {number}
     * @memberof AggregatedMeasurement
     */
    confidenceLevel: number;
}

/**
 * Check if a given object implements the AggregatedMeasurement interface.
 */
export function instanceOfAggregatedMeasurement(value: object): value is AggregatedMeasurement {
    if (!('measurementTime' in value) || value['measurementTime'] === undefined) return false;
    if (!('value' in value) || value['value'] === undefined) return false;
    if (!('medianValue' in value) || value['medianValue'] === undefined) return false;
    if (!('pointCount' in value) || value['pointCount'] === undefined) return false;
    if (!('lowerBound' in value) || value['lowerBound'] === undefined) return false;
    if (!('upperBound' in value) || value['upperBound'] === undefined) return false;
    if (!('parametricLowerBound' in value) || value['parametricLowerBound'] === undefined) return false;
    if (!('parametricUpperBound' in value) || value['parametricUpperBound'] === undefined) return false;
    if (!('stdDev' in value) || value['stdDev'] === undefined) return false;
    if (!('minValue' in value) || value['minValue'] === undefined) return false;
    if (!('maxValue' in value) || value['maxValue'] === undefined) return false;
    if (!('percentile25' in value) || value['percentile25'] === undefined) return false;
    if (!('percentile75' in value) || value['percentile75'] === undefined) return false;
    if (!('ciMethod' in value) || value['ciMethod'] === undefined) return false;
    if (!('confidenceLevel' in value) || value['confidenceLevel'] === undefined) return false;
    return true;
}

export function AggregatedMeasurementFromJSON(json: any): AggregatedMeasurement {
    return AggregatedMeasurementFromJSONTyped(json, false);
}

export function AggregatedMeasurementFromJSONTyped(json: any, ignoreDiscriminator: boolean): AggregatedMeasurement {
    if (json == null) {
        return json;
    }
    return {
        
        'measurementTime': (new Date(json['measurement_time'])),
        'value': json['value'],
        'medianValue': json['median_value'],
        'pointCount': json['point_count'],
        'lowerBound': json['lower_bound'],
        'upperBound': json['upper_bound'],
        'parametricLowerBound': json['parametric_lower_bound'],
        'parametricUpperBound': json['parametric_upper_bound'],
        'stdDev': json['std_dev'],
        'minValue': json['min_value'],
        'maxValue': json['max_value'],
        'percentile25': json['percentile_25'],
        'percentile75': json['percentile_75'],
        'ciMethod': json['ci_method'],
        'confidenceLevel': json['confidence_level'],
    };
}

export function AggregatedMeasurementToJSON(json: any): AggregatedMeasurement {
    return AggregatedMeasurementToJSONTyped(json, false);
}

export function AggregatedMeasurementToJSONTyped(value?: AggregatedMeasurement | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'measurement_time': ((value['measurementTime']).toISOString()),
        'value': value['value'],
        'median_value': value['medianValue'],
        'point_count': value['pointCount'],
        'lower_bound': value['lowerBound'],
        'upper_bound': value['upperBound'],
        'parametric_lower_bound': value['parametricLowerBound'],
        'parametric_upper_bound': value['parametricUpperBound'],
        'std_dev': value['stdDev'],
        'min_value': value['minValue'],
        'max_value': value['maxValue'],
        'percentile_25': value['percentile25'],
        'percentile_75': value['percentile75'],
        'ci_method': value['ciMethod'],
        'confidence_level': value['confidenceLevel'],
    };
}

